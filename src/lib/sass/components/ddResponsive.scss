/*
	DivoDivnoe Responsive
	Зависит от "DivoDivnoe Space", "DivoDivnoe Helpers"
*/

/*
	Массив размеров устройств, каждый размер может содержать следующие параметры:
	cutoff - отсечка в пикселях. (обязательно если не указан range)
	range: [val1, val2] - минимальная и максимальная ширина viewport (обязательно если не указан cutoff)
	containerWidth - ширина контейнера (по умолчанию равен cutoff)
	spaceScale - множитель отступов
*/
$dd-responsive-breakpoints: (
	xs:(
		cutoff: 0,
		containerWidth: 100%,
		spaceScale: 0.5,
	),
	sm:(
		cutoff: 544px,
		spaceScale: 0.5,
	),
	md:(
		cutoff: 768px,
		spaceScale: 0.75,
	),
	lg:(
		cutoff: 992px,
		spaceScale: 1,
	),
	xl:(
		cutoff: 1200px,
		spaceScale: 2,
	),
) !default

/*
	TODO медиа выражение, в пределах которого будет работать адавтивность
*/
$dd-responsive-mediaBounds: null !default;

$dd-responsive-spaceFixedMod: fixed !default;

// Возвращает параметр отсечки по имени отсечки и имени параметра
@function dd-responsive-breakpointVal($_breakpoint, $_param)
{
	@return map_get(map_get($dd-responsive-breakpoints, $_breakpoint), $_param);
}

// Возвращает минимальную ширину для отсечки
@function dd-responsive-minWidth($_breakpoint)
{
	@return nth(dd-responsive-breakpointVal($_breakpoint, range), 1);
}

// Возвращает максимальную ширину для отсечки
@function dd-responsive-maxWidth($_breakpoint)
{
	@return nth(dd-responsive-breakpointVal($_breakpoint, range), 2);
}

// Возвращает среднее значение между минимальными ширинами отсечки
@function dd-responsive-minMeanWidth($_breakpoint1, $_breakpoint2, $_offset: 0.5)
{
	@return dd-helpers-getMean(dd-responsive-minWidth($_breakpoint1), dd-responsive-minWidth($_breakpoint2), $_offset);
}

// Возвращает среднее значение между максимальными ширинами отсечки
@function dd-responsive-maxMeanWidth($_breakpoint1, $_breakpoint2, $_offset: 0.5)
{
	@return dd-helpers-getMean(dd-responsive-maxWidth($_breakpoint1), dd-responsive-maxWidth($_breakpoint2), $_offset);
}

// Возвращает следующее имя отсейчки или null если такой нет
// TODO потенциальная проблема если отсечки не по порядку
@function dd-responsive-nextBreakpointName($_breakpoint)
{
	$_keys: map_keys($dd-responsive-breakpoints);
	$_index: index($_keys, $_breakpoint);
	@if ($_index + 1) <= length($_keys) {
		@return nth($_keys, $_index + 1);
	} @else {
		@return null
	}
}

// Возвращает мапу следующей отсейчки или null если такой нет
@function dd-responsive-nextBreakpoint($_breakpoint)
{
	$_nextName: dd-responsive-nextBreakpointName($_breakpoint);
	@if $_nextName {
		@return map-get($dd-responsive-breakpoints, $_nextName)
	} @else {
		@return null
	}
}

@function dd-responsive-parseMedia($_args...)
{
	$_result: ();
	@each $_arg in $_args {
		$_firstPoint: null;
		$_secondPoint: null;
		@if (type_of($_arg) == 'list') {
			$_p1: nth($_arg, 1);
			$_p2: nth($_arg, 2);
			@if ($_p1) {
				// Если указаны два параметра
				@if ($_p2) {
					// Преобразуем точки
					@if (type-of($_p1) == 'number') {
						$_firstPoint: $_p1;
					} @else {
						$_firstPoint: dd-responsive-minWidth($_p1);
					}
					@if (type-of($_p2) == 'number') {
						$_secondPoint: $_p2;
					} @else {
						@if ($_p2 == infinite) {
							$_secondPoint: null;
						} @else {
							$_secondPoint: dd-responsive-maxWidth($_p2);
						}
					}
				}
				// Если указан только первый параметр
				@else {
					@if (type-of($_p1) == 'number') {
						@error 'Если указан 1 параметр "#{$_arg}" - он должен быть именем интервала';
					} @else {
						$_firstPoint: dd-responsive-minWidth($_p1);
						$_secondPoint: dd-responsive-maxWidth($_p1);
					}
				}
			}
		} @elseif (type_of($_arg) == 'string') {
			$_firstPoint: dd-responsive-minWidth($_arg);
			$_secondPoint: dd-responsive-maxWidth($_arg);
		}
		@if ($_secondPoint) {
			$_result: append($_result, 'all and (min-width: #{$_firstPoint}) and (max-width: #{$_secondPoint})', comma);
		} @else {
			$_result: append($_result, 'all and (min-width: #{$_firstPoint})', comma);
		}
	}
	@return $_result;
}

@mixin dd-responsive-media($_args...)
{
	@media #{dd-helpers-implode(dd-responsive-parseMedia($_args...), ', ')} {
		@content;
	}
}

// Генерирует адаптивные вспомогательные свойства
// для переданного брейкпойнта в заданном направлении (up\down)
@mixin _dd-responsive-helpers($_key, $_dir: null)
{
	@if ($_dir) {
		$_dir: '-#{$_dir}';
	} @else {
		$_dir: '';
	}
	@each $_name, $_params in $dd-helpers-map {
		.__#{$dd-system-classPrefix}#{$_name}-#{$_key}#{$_dir} {
			@each $_prop, $_value in $_params {
				#{$_prop}: #{$_value} !important;
			}
		}
	}
}

@function dd-responsive-normalizeBreakpoints($_breakpoints)
{
	// Проходим по брейкпойнтам, проставляя недостающие данные
	$_newBreakpoints: ();
	@each $_key, $_params in $_breakpoints {
		$_cutoff: map_get($_params, 'cutoff');
		$_range: map_get($_params, 'range');
		$_minWidth: null;
		$_maxWidth: null;
		@if ($_range) {
			$_minWidth: nth($_range, 1);
			$_maxWidth: nth($_range, 2);
		}
		$_containerWidth: map_get($_params, 'containerWidth');
		$_containerGutter: map_get($_params, 'containerGutter');
		$_gridGutterHorizontal: map_get($_params, 'gridGutterHorizontal');
		$_gridGutterVertical: map_get($_params, 'gridGutterVertical');
		$_spaceScale: map_get($_params, 'spaceScale');
		$_nextBreakpoint: dd-responsive-nextBreakpoint($_key);

		// Нормализуем range и cutoff
		@if ($_cutoff) {
			@if ($_minWidth or $_maxWidth) {
				@error 'Для отсечки #{$_key} должны быть указаны minWidth и maxWidth ИЛИ cutoff';
			}
			@if ($_nextBreakpoint) {
				$_nextCutoff: map_get($_nextBreakpoint, 'cutoff');
				@if (not $_nextCutoff) {
					$_nextRange: map_get($_nextBreakpoint, 'range');
					$_nextCutoff: nth($_nextRange, 1);
				}
				@if (not $_nextCutoff) {
					@error 'Для отсейчки следующей за #{$_key} нет minWidth или cutoff';
				}
				$_params: map_merge($_params, (
					range: ($_cutoff, $_nextCutoff - 1px)
				));
			} @else {
				$_params: map_merge($_params, (
					range: ($_cutoff, null)
				));
			}
		} @else {
			@if (not $_minWidth or not $_maxWidth) {
				@error 'Для отсечки #{$_key} должны быть указаны minWidth и maxWidth ИЛИ cutoff';
			}
			$_params: map_merge($_params, (
				cutoff: $_minWidth,
			));
		}

		// Проставляем containerWidth
		@if (not $_containerWidth) {
			$_params: map_merge($_params, (
				containerWidth: map_get($_params, 'cutoff'),
			));
		}

		// Проставляем spaceScale
		@if (not $_spaceScale) {
			$_params: map_merge($_params, (
				spaceScale: 1,
			));
		}

		$_newBreakpoints: map-merge($_newBreakpoints, (
			$_key: $_params,
		));
	}
	@return $_newBreakpoints;
}

@mixin dd-responsive-space($_val)
{
	display: block;
	$_val: dd-space-getSpace($_val);
	// Генерируем вспомогательные классы Space компонента
	@each $_key, $_params in $dd-responsive-breakpoints {
		@include dd-responsive-media(($_key)) {
			height: $_val * map_get($_params, 'spaceScale');
		}
	}
}

// Сохраняем новую мапу брейкпойнтов
$dd-responsive-breakpoints: dd-responsive-normalizeBreakpoints($dd-responsive-breakpoints);

// Генерируем вспомогательные классы Helpers компонента
@each $_key, $_params in $dd-responsive-breakpoints {
	$_range: map_get($_params, 'range');
	$_min: nth($_range, 1);
	$_max: nth($_range, 2);

	@include dd-responsive-media(($_key, infinite)) {
		@include _dd-responsive-helpers($_key, up);
	}

	@if $_max {
		@include dd-responsive-media((0, $_key)) {
			@include _dd-responsive-helpers($_key, down)
		}
		@include dd-responsive-media($_key) {
			@include _dd-responsive-helpers($_key)
		}
	} @else {
		@include _dd-responsive-helpers($_key, down);
		@include dd-responsive-media(($_key, infinite)) {
			@include _dd-responsive-helpers($_key)
		}
	}
}

// Генерируем вспомогательные классы Space компонента
.#{$dd-system-classPrefix}space {
	@each $_factorKey, $_factorVal in $dd-space-factor {
		$_val: dd-space-getSpace($_factorKey);
		@each $_breakKey, $_breakParams in $dd-responsive-breakpoints {
			@include dd-responsive-media($_breakKey) {
				&._#{$_factorKey} {
					height: $_val * map_get($_breakParams, 'spaceScale');
				}
			}
		}
		&._#{$_factorKey}._#{$dd-responsive-spaceFixedMod} {
			height: $_val;
		}
	}
}