/*
	DivoDivnoe Responsive
*/

@include dd-system-componentRegister(ddResponsive);

/*
	Массив размеров устройств, каждый размер может содержать следующие параметры:
	cutoff - отсечка в пикселях. (обязательно если не указан range)
	range: [val1, val2] - минимальная и максимальная ширина viewport (обязательно если не указан cutoff)
	containerWidth - ширина контейнера (по умолчанию равен cutoff)
*/
$dd-responsive-breakpoints: (
	xs:(
		cutoff: 0,
		containerWidth: 100%,
		spaceScale: 0.5,
		typHScale: 0.5,
	),
	sm:(
		cutoff: 544px,
		spaceScale: 0.5,
		typHScale: 0.7,
	),
	md:(
		cutoff: 768px,
		spaceScale: 0.75,
		typHScale: 0.8,
	),
	lg:(
		cutoff: 992px,
		spaceScale: 1,
		typHScale: 1,
	),
	xl:(
		cutoff: 1200px,
		spaceScale: 1.5,
		typHScale: 1,
	),
) !default

// Возвращает параметр отсечки по имени отсечки и имени параметра
@function dd-responsive-breakpointVal($_breakpoint, $_param)
{
	@return map_get(map_get($dd-responsive-breakpoints, $_breakpoint), $_param);
}

// Возвращает минимальную ширину для отсечки
@function dd-responsive-minWidth($_breakpoint)
{
	@return nth(dd-responsive-breakpointVal($_breakpoint, range), 1);
}

// Возвращает максимальную ширину для отсечки
@function dd-responsive-maxWidth($_breakpoint)
{
	@return nth(dd-responsive-breakpointVal($_breakpoint, range), 2);
}

// Возвращает среднее значение между минимальными ширинами отсечки
@function dd-responsive-minMeanWidth($_breakpoint1, $_breakpoint2, $_offset: 0.5)
{
	@return dd-util-getMean(dd-responsive-minWidth($_breakpoint1), dd-responsive-minWidth($_breakpoint2), $_offset);
}

// Возвращает среднее значение между максимальными ширинами отсечки
@function dd-responsive-maxMeanWidth($_breakpoint1, $_breakpoint2, $_offset: 0.5)
{
	@return dd-util-getMean(dd-responsive-maxWidth($_breakpoint1), dd-responsive-maxWidth($_breakpoint2), $_offset);
}

// Возвращает следующее имя отсейчки или null если такой нет
// TODO потенциальная проблема если отсечки не по порядку
@function dd-responsive-nextBreakpointName($_breakpoint)
{
	$_keys: map_keys($dd-responsive-breakpoints);
	$_index: index($_keys, $_breakpoint);
	@if ($_index + 1) <= length($_keys) {
		@return nth($_keys, $_index + 1);
	} @else {
		@return null
	}
}

// Возвращает мапу следующей отсейчки или null если такой нет
@function dd-responsive-nextBreakpoint($_breakpoint)
{
	$_nextName: dd-responsive-nextBreakpointName($_breakpoint);
	@if $_nextName {
		@return map-get($dd-responsive-breakpoints, $_nextName)
	} @else {
		@return null
	}
}

@function dd-responsive-parseMedia($_args...)
{
	$_result: ();
	@each $_arg in $_args {
		$_firstPoint: null;
		$_secondPoint: null;
		@if (type_of($_arg) == 'list') {
			$_p1: nth($_arg, 1);
			$_p2: nth($_arg, 2);
			@if ($_p1) {
				// Если указаны два параметра
				@if ($_p2) {
					// Преобразуем точки
					@if (type-of($_p1) == 'number') {
						$_firstPoint: $_p1;
					} @else {
						$_firstPoint: dd-responsive-minWidth($_p1);
					}
					@if (type-of($_p2) == 'number') {
						$_secondPoint: $_p2;
					} @else {
						@if ($_p2 == infinite) {
							$_secondPoint: null;
						} @else {
							$_secondPoint: dd-responsive-maxWidth($_p2);
						}
					}
				}
				// Если указан только первый параметр
				@else {
					@if (type-of($_p1) == 'number') {
						@error 'Если указан 1 параметр "#{$_arg}" - он должен быть именем интервала';
					} @else {
						$_firstPoint: dd-responsive-minWidth($_p1);
						$_secondPoint: dd-responsive-maxWidth($_p1);
					}
				}
			}
		} @elseif (type_of($_arg) == 'string') {
			$_firstPoint: dd-responsive-minWidth($_arg);
			$_secondPoint: dd-responsive-maxWidth($_arg);
		}
		@if ($_secondPoint) {
			$_result: append($_result, 'all and (min-width: #{$_firstPoint}) and (max-width: #{$_secondPoint})', comma);
		} @else {
			$_result: append($_result, 'all and (min-width: #{$_firstPoint})', comma);
		}
	}
	@return $_result;
}

@mixin dd-responsive-media($_args...)
{
	@media #{dd-util-implode(dd-responsive-parseMedia($_args...), ', ')} {
		@content;
	}
}

@function dd-responsive-lock($_to, $_from, $_toWidth, $_fromWidth) {
	$_slope: ($_to - $_from) / ($_toWidth - $_fromWidth);
	$_base: $_from - $_slope * $_fromWidth;

	@return calc(#{$_base} + #{100vw * $_slope});
}

@function _dd-responsive-normalizeBreakpoints($_breakpoints)
{
	// Проходим по брейкпойнтам, проставляя недостающие данные
	$_newBreakpoints: ();
	@each $_key, $_params in $_breakpoints {
		$_cutoff: map_get($_params, 'cutoff');
		$_range: map_get($_params, 'range');
		$_minWidth: null;
		$_maxWidth: null;
		@if ($_range) {
			$_minWidth: nth($_range, 1);
			$_maxWidth: nth($_range, 2);
		}
		$_containerWidth: map_get($_params, 'containerWidth');
		$_containerGutter: map_get($_params, 'containerGutter');
		$_gridGutterHorizontal: map_get($_params, 'gridGutterHorizontal');
		$_gridGutterVertical: map_get($_params, 'gridGutterVertical');
		$_spaceScale: map_get($_params, 'spaceScale');
		$_nextBreakpoint: dd-responsive-nextBreakpoint($_key);

		// Нормализуем range и cutoff
		@if ($_cutoff) {
			@if ($_minWidth or $_maxWidth) {
				@error 'Для отсечки #{$_key} должны быть указаны minWidth и maxWidth ИЛИ cutoff';
			}
			@if ($_nextBreakpoint) {
				$_nextCutoff: map_get($_nextBreakpoint, 'cutoff');
				@if (not $_nextCutoff) {
					$_nextRange: map_get($_nextBreakpoint, 'range');
					$_nextCutoff: nth($_nextRange, 1);
				}
				@if (not $_nextCutoff) {
					@error 'Для отсейчки следующей за #{$_key} нет minWidth или cutoff';
				}
				$_params: map_merge($_params, (
					range: ($_cutoff, $_nextCutoff - 1px)
				));
			} @else {
				$_params: map_merge($_params, (
					range: ($_cutoff, null)
				));
			}
		} @else {
			@if (not $_minWidth or not $_maxWidth) {
				@error 'Для отсечки #{$_key} должны быть указаны minWidth и maxWidth ИЛИ cutoff';
			}
			$_params: map_merge($_params, (
				cutoff: $_minWidth,
			));
		}

		// Проставляем containerWidth
		@if (not $_containerWidth) {
			$_params: map_merge($_params, (
				containerWidth: map_get($_params, 'cutoff'),
			));
		}

		$_newBreakpoints: map-merge($_newBreakpoints, (
			$_key: $_params,
		));
	}
	@return $_newBreakpoints;
}

@function dd-responsive-normalizeBreakpoints($_breakpoints, $_defaults)
{
	$_newBreakpoints: ();
	@each $_key, $_params in $_breakpoints {
		@each $_defaultKey, $_defaultVal in $_defaults {
			@if (not map_get($_params, $_defaultKey)) {
				$_params: map_merge($_params, (
					$_defaultKey: $_defaultVal,
				));
			}
		}
		$_newBreakpoints: map-merge($_newBreakpoints, (
			$_key: $_params,
		));
	}
	@return $_newBreakpoints;
}

// Сохраняем новую мапу брейкпойнтов
$dd-responsive-breakpoints: _dd-responsive-normalizeBreakpoints($dd-responsive-breakpoints);